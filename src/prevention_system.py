# -*- coding: utf-8 -*-
"""Mold Prevention System (Core Logic)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Wjf06kMkXdYa2Q-ol6eEAFS1k5Gu1LhO
"""

import paho.mqtt.client as mqtt
import json
import time

# --- Configuration ---
MQTT_BROKER = "test.mosquitto.org"
MQTT_PORT = 1883
SUBSCRIBE_TOPIC = "iitbhu/mold_prevention/room/#"  # Subscribe to all rooms

# --- Mold Risk Prediction Model (Stateful) ---
# This dictionary will store the current state for each room
room_states = {}

# Constants for the model
HUMIDITY_THRESHOLD = 70.0  # %RH - Mold growth is significantly more likely above this
TEMP_THRESHOLD = 20.0      # °C - Mold prefers warmer temperatures
RISK_INCREMENT = 10        # Points to add to risk score per interval when conditions are met
RISK_DECREMENT = 5         # Points to subtract when conditions are not met
RISK_ACTION_THRESHOLD = 80 # Score at which to trigger an action

def update_mold_risk(room, temperature, humidity):
    """
    A simple stateful algorithm to calculate mold risk.
    Risk increases when humidity and temperature are high for a sustained period.
    """
    # Initialize state for a new room
    if room not in room_states:
        room_states[room] = {"risk_score": 0, "last_update": time.time()}

    state = room_states[room]

    # Check if conditions for mold growth are met
    if humidity > HUMIDITY_THRESHOLD and temperature > TEMP_THRESHOLD:
        state["risk_score"] += RISK_INCREMENT
        print(f"INFO [{room}]: Conditions met. Risk score increased to {state['risk_score']}.")
    else:
        state["risk_score"] -= RISK_DECREMENT
        print(f"INFO [{room}]: Conditions normal. Risk score decreased to {state['risk_score']}.")

    # Clamp the risk score to be between 0 and 100
    state["risk_score"] = max(0, min(100, state["risk_score"]))

    # Check if action is needed
    if state["risk_score"] > RISK_ACTION_THRESHOLD:
        print(f"!!! ALERT [{room}] !!! High Mold Risk Detected (Score: {state['risk_score']}). ACTION: Activate Dehumidifier/Ventilation.")

    state["last_update"] = time.time()
    return state["risk_score"]


# --- MQTT Callback Functions ---
def on_connect(client, userdata, flags, rc, properties):
    if rc == 0:
        print("Successfully connected to MQTT Broker!")
        client.subscribe(SUBSCRIBE_TOPIC)
        print(f"Subscribed to topic: {SUBSCRIBE_TOPIC}")
    else:
        print(f"Failed to connect, return code {rc}\n")

def on_message(client, userdata, msg):
    """Handles incoming messages from the sensor nodes."""
    try:
        payload = json.loads(msg.payload.decode())
        room = payload.get("room")
        temperature = payload.get("temperature")
        humidity = payload.get("humidity")

        if room and temperature is not None and humidity is not None:
            print(f"\nReceived data from [{room}]: Temp={temperature}°C, Humidity={humidity}%")
            # Update the predictive model
            update_mold_risk(room, temperature, humidity)
        else:
            print("Received malformed data.")

    except json.JSONDecodeError:
        print("Error decoding JSON from message.")
    except Exception as e:
        print(f"An error occurred in on_message: {e}")

# --- Main Execution ---
client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2, client_id="prevention_system_core")
client.on_connect = on_connect
client.on_message = on_message

try:
    client.connect(MQTT_BROKER, MQTT_PORT, 60)
    # loop_forever() is a blocking call that handles reconnection automatically.
    client.loop_forever()
except KeyboardInterrupt:
    print("System stopped by user.")
finally:
    client.disconnect()
    print("Disconnected from MQTT Broker.")