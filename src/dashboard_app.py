# -*- coding: utf-8 -*-
"""Web Dashboard Application

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1e7Dym44-YxBWBLl_lLjoT3jSP5VziXU9
"""

from flask import Flask, render_template
from flask_socketio import SocketIO
import paho.mqtt.client as mqtt
import json
import time

# --- Flask and SocketIO Setup ---
app = Flask(__name__)
app.config['SECRET_KEY'] = 'secret!'
socketio = SocketIO(app, cors_allowed_origins="*")

# --- MQTT Configuration ---
MQTT_BROKER = "test.mosquitto.org"
MQTT_PORT = 1883
SUBSCRIBE_TOPIC = "iitbhu/mold_prevention/room/#"

# --- In-memory data store for the dashboard ---
# This will hold the latest data for each room
dashboard_data = {
    "bathroom": {"temperature": 0, "humidity": 0, "risk_score": 0},
    "basement": {"temperature": 0, "humidity": 0, "risk_score": 0},
    "kitchen": {"temperature": 0, "humidity": 0, "risk_score": 0}
}

# --- Mold Risk Prediction Model (A copy for the dashboard) ---
# This is simplified and mirrors the logic in prevention_system.py for visualization
HUMIDITY_THRESHOLD = 70.0
TEMP_THRESHOLD = 20.0
RISK_INCREMENT = 10
RISK_DECREMENT = 5

def update_dashboard_risk(room, temperature, humidity):
    """Updates the risk score for the dashboard."""
    state = dashboard_data.get(room)
    if not state:
        return 0

    if humidity > HUMIDITY_THRESHOLD and temperature > TEMP_THRESHOLD:
        state["risk_score"] += RISK_INCREMENT
    else:
        state["risk_score"] -= RISK_DECREMENT

    state["risk_score"] = max(0, min(100, state["risk_score"]))
    return state["risk_score"]

# --- MQTT Client for Dashboard ---
def on_connect(client, userdata, flags, rc, properties):
    if rc == 0:
        print("Dashboard MQTT client connected.")
        client.subscribe(SUBSCRIBE_TOPIC)
    else:
        print(f"Dashboard MQTT connection failed, code {rc}")

def on_message(client, userdata, msg):
    """Callback for when a message is received from MQTT."""
    try:
        payload = json.loads(msg.payload.decode())
        room = payload.get("room")

        if room in dashboard_data:
            # Update the latest sensor readings
            dashboard_data[room]["temperature"] = payload.get("temperature")
            dashboard_data[room]["humidity"] = payload.get("humidity")

            # Update the risk score
            update_dashboard_risk(room, payload.get("temperature"), payload.get("humidity"))

            # Emit the updated data to all connected web clients
            socketio.emit('update_data', dashboard_data)
            print(f"Sent updated data to dashboard: {dashboard_data}")

    except Exception as e:
        print(f"Error in on_message for dashboard: {e}")

# Setup and start the MQTT client in a background thread
mqtt_client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2)
mqtt_client.on_connect = on_connect
mqtt_client.on_message = on_message
mqtt_client.connect(MQTT_BROKER, MQTT_PORT, 60)
mqtt_client.loop_start()

# --- Flask Routes ---
@app.route('/')
def index():
    """Serves the main dashboard page."""
    return render_template('index.html')

@socketio.on('connect')
def handle_connect():
    """Handles new client connections."""
    print('Client connected to dashboard.')
    # Send the current data state to the newly connected client
    socketio.emit('update_data', dashboard_data)

if __name__ == '__main__':
    print("Starting Flask-SocketIO server at http://127.0.0.1:5000")
    socketio.run(app, debug=True, use_reloader=False) # use_reloader=False to avoid running setup twice